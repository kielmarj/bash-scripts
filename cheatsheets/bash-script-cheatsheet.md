<!--
File: bash-script-cheatsheet.md
Date: 2024-10-14
Gist: <https://gist.github.com/kielmarj/44d69ea9907cd0a51b0cd5b3ba089348>
Bash script repo: <https://github.com/kielmarj/bash-scripts>
Author: Jessica Kielmar <https://github.com/kielmarj>
Copyright: © 2024 Jessica Kielmar
License: Creative Commons Attributions 4.0 International (CC BY 4.0) <https://creativecommons.org/licenses/by/4.0/>
-->
<sub>© 2024 [kielmarj](https://github.com/kielmarj), [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/)</sub>
# Bash Script Cheatsheet

### General Operators
| Operator  | Description                                                                                                                                                                                                                                                                                                                      | Example                    |
|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------|
| `=`       | **Variable assignment** Assigns a value to a variable, allowing you to store data in a variable and use it throughout the script. Variables can hold numbers, strings, or command outputs, making them versatile tools for automating tasks.                                                                                     | `var=value`                |
| `;`       | **Command separator** Executes `cmd2` after `cmd1` completes. This is useful for running multiple commands sequentially in a single line, ensuring the previous command finishes before the next starts. Command separation allows for clear and organized script flow, especially when commands depend on each other's success. | `cmd1; cmd2`               |
| `&`       | **Run job in background** Background processes allow other commands to continue running without waiting for the current process to complete, which is ideal for long-running tasks. This is useful for multi-tasking in scripts or when automating processes that do not need user interaction.                                  | `cmd1 &`                   |
| `\|`      | **Pipe** Piping allows you to chain commands together, sending the output of one command as input to another, effectively combining commands to process data in stages. Pipes are often used for filtering text and combining different Unix utilities efficiently.                                                              | `cmd1 \| cmd2`             |
| `&&`      | **AND operator** Ensures that the second command runs only if the first command returns a successful exit status (0). This is a common method for conditional execution in scripts, ensuring certain steps are completed before proceeding.                                                                                      | `cmd1 && cmd2`             |
| `\|\|`    | **OR operator** Runs the second command only if the first command fails (returns a non-zero exit status). This is useful for providing fallback actions in case of errors, such as retrying a command or logging an error message.                                                                                               | `cmd1 \|\| cmd2`           |
| `>`       | **Redirect stdout (overwrites)** Essential for capturing command output in files, which can be used for logging or further analysis. The `>` operator ensures that the existing contents of the file are replaced with the new output.                                                                                           | `cmd1 > file.txt`          |
| `>>`      | **Redirect stdout (appends)** This operator appends output to an existing file without overwriting its contents, making it ideal for logging where each new entry should be added to the end of the file.                                                                                                                        | `echo "Hello" >> file.txt` |
| `2>`      | **Redirect stderr** Useful for debugging, as it separates error messages from standard output, making it easier to identify issues.                                                                                                                                                                                              | `cmd1 2> error.log`        |
| `&>`      | **Redirect both stdout & stderr** Captures all command output, both successful and error messages, in one file, simplifying log management.                                                                                                                                                                                      | `cmd1 &> output.log`       |
| `$( )`    | **Command substitution** Allows the output of a command to be used as a variable value, enabling dynamic values to be assigned based on command results. This is often used to capture the results of system commands within scripts.                                                                                            | `var=$(cmd1)`              |
| `` ` ` `` | **Command substitution (legacy)** Older syntax for command substitution, still supported for compatibility. Useful in older scripts but generally replaced by `$( )` for better readability.                                                                                                                                     | `` var=`cmd1` ``           |
| `$`       | **Variable substitution** Allows the value of a variable to be used in commands, making scripts more flexible and dynamic. This is the primary method for interacting with stored data in Bash.                                                                                                                                  | `echo $VAR`                |

### Variable Expansion and Substitution
| Syntax                                 | Description                                                                                                                                                                                                            | Example                                |
|----------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------|
| `${}`                                  | Expands the value of a variable. This form is particularly useful for distinguishing variable names from surrounding text, ensuring the correct value is expanded. It also supports complex substitutions.             | `echo ${VAR}`                          |
| `${#var}`                              | Returns the length of a string. This is useful for checking the number of characters in a string, which can be helpful for input validation or processing text.                                                        | `echo ${#my_string}`                   |
| `${var:startPosition:extractedLength}` | Extracts substring from a string. String slicing helps in extracting specific parts of a string, useful for parsing data and working with text efficiently.                                                            | `echo ${my_string:2:4}`                |
| `${var/oldPattern/newPattern}`         | Replaces the first occurrence of `oldPattern` with `newPattern` in a string. This allows for simple inline modifications of strings, which is useful for tasks like replacing file paths or modifying command outputs. | `echo ${my_var/oldPattern/newPattern}` |
| `${var:-default}`                      | Prints a default variable value if the variable is unset or null. This is useful for providing fallback values in scripts.                                                                                             | `echo ${my_var:-default_value}`        |
| `${var:+alternate}`                    | Prints an alternate variable value only if the variable is already set and is not not null. This is useful for conditional substitution based on the presence of a variable.                                           | `echo ${my_var:+alternate_value}`      |

### Control Structures
| Structure        | Description                                                                                                                                                                                                           | Example                                                                            |
|------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------|
| `if...then...fi` | Executes the block if the condition is true. Control structures are used for branching logic, making scripts respond differently based on conditions, which is fundamental for creating dynamic behavior in scripts.  | `if [ "$var" -eq 1 ]; then echo "Yes"; fi`                                         |
| `if...else...fi` | Executes one block if true, another if false. The else clause allows you to handle both success and failure paths within a single control structure, providing a complete branching mechanism.                        | `if [ "$var" -eq 1 ]; then echo "Yes"; else echo "No"; fi`                         |
| `elif`           | Checks multiple conditions in sequence. Elif statements allow for multiple branches of execution, useful when more than two possible outcomes need to be handled.                                                     | `if [ "$var" -eq 1 ]; then echo "One"; elif [ "$var" -eq 2 ]; then echo "Two"; fi` |
| `for` loop       | Iterates over each value in a range or list. Loops are essential for repeating commands multiple times, automating repetitive tasks such as processing a list of files.                                               | `for i in {1..5}; do echo $i; done`                                                |
| `while` loop     | Executes while the condition is true. While loops are useful for scenarios where you need to keep running a block of code until a specific condition is met.                                                          | `while [ "$count" -lt 5 ]; do echo $count; ((count++)); done`                      |
| `until` loop     | Executes until the condition is true. The until loop works similarly to a while loop, but runs until the given condition is satisfied, providing flexibility in loop logic.                                           | `until [ "$count" -eq 5 ]; do echo $count; ((count++)); done`                      |
| `case...esac`    | Matches the value of a variable against patterns. Case statements are helpful for handling multiple discrete values, making code more readable and organized, especially when dealing with multiple potential inputs. | `case "$var" in 1) echo "One" ;; 2) echo "Two" ;; esac`                            |

### Functions and Arrays
| Structure         | Description                                                                                                                                                                                  | Example                               |
|-------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------|
| `function`        | Defines a reusable block of code that takes arguments. Functions promote code reuse, modularity, and improved readability by allowing repetitive tasks to be encapsulated in a single block. | `function greet { echo "Hello $1"; }` |
| `array=( )`       | Declares an array and assigns values. Arrays are used for storing multiple values in a single variable, allowing easy iteration and manipulation of data sets.                               | `my_array=(one two three)`            |
| `${array[@]}`     | Outputs all elements of the array. Accessing all elements at once is useful for looping through array values or printing them collectively.                                                  | `echo ${my_array[@]}`                 |
| `${array[index]}` | Outputs the element at the specified index. This allows direct access to individual items in the array for manipulation or retrieval.                                                        | `echo ${my_array[1]}`                 |
| `${#array[@]}`    | Returns the number of elements in the array. This is helpful for iteration and managing array size dynamically.                                                                              | `echo ${#my_array[@]}`                |
| `unset`           | Removes the element at the specified index. Useful for deleting elements in an array without affecting other values.                                                                         | `unset my_array[1]`                   |

### Logical and Arithmetic Evaluations
| Syntax   | Description                                                                                                                                                | Example                   |
|----------|------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------|
| `[]`     | **Tests** are used for evaluating conditions as true or false.                                                                                             | `[ "$var" -eq 1 ]`        |
| `[[ ]]`  | **Extended tests** provide more advanced conditional capabilities, including string comparison and pattern matching.                                       | `[[ "$var" == "value" ]]` |
| `!`      | **Negation** is used to reverse the logic of a test, enabling complex conditional constructs by checking if conditions are not met.                        | `! [ "$var" -eq 1 ]`      |
| `$(( ))` | Evaluates an **arithmetic expression**. Arithmetic evaluation allows basic math operations within scripts, useful for calculations and counter increments. | `echo $((5 + 3))`         |
| `(( ))`  | **Performs arithmetic** and returns a status. This syntax simplifies arithmetic manipulation, especially for loop counters and conditional calculations.   | `((count++))`             |
| `let`    | Another way to perform **arithmetic operations**. Useful for incrementing or modifying variables without needing `$(( ))`.                                 | `let count+=1`            |

### File Operations
| Command | Description                                                                                                                                                            | Example                          |
|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------|
| `>`     | Overwrites a file with command output. Useful for creating or overwriting files with command results, which is fundamental for logging and saving data.                | `cmd > file.txt`                 |
| `>>`    | Appends data to a file. Appending ensures existing data is preserved while new data is added, which is useful for maintaining logs over time.                          | `echo "data" >> file.txt`        |
| `<`     | Redirects data as command input. Redirecting input allows commands to take data from a file instead of interactive input, automating data processing tasks.            | `cmd < file.txt`                 |
| `\|`    | Pipes `cmd1` output to `cmd2`. Piping is a fundamental way of connecting different commands to build powerful workflows, transforming data step by step.               | `cmd1 \| cmd2`                   |
| `tee`   | Writes output to both a file and the terminal. Tee is useful for capturing output while still displaying it, enabling real-time monitoring alongside logging.          | `cmd \| tee file.txt`            |
| `xargs` | Takes input and constructs command lines. Xargs allows efficient handling of arguments from standard input, which is useful for executing commands on a list of items. | `echo "file1 file2" \| xargs rm` |
| `cat`   | Displays the content of a file. Useful for viewing text files or combining multiple files into one.                                                                    | `cat file.txt`                   |
| `touch` | Creates a new empty file or updates the timestamp of an existing file. Useful for managing files in scripts.                                                           | `touch newfile.txt`              |

### Job Control and Process Management
| Command   | Description                                                                                                                                                                        | Example              |
|-----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------|
| `&`       | Runs a command in the background. Backgrounding allows other tasks to continue without waiting, which is essential for multi-tasking and managing long-running processes.          | `cmd &`              |
| `wait`    | Waits for a specific background process. Wait is used to synchronize tasks by ensuring that a background job completes before proceeding, avoiding conflicts or dependency issues. | `wait $pid`          |
| `jobs`    | Displays the status of background jobs. Listing jobs helps manage running processes, providing insight into which tasks are still in progress.                                     | `jobs`               |
| `$!`      | Prints the PID of the last background command. Knowing the PID is useful for managing or terminating specific processes.                                                           | `sleep 10 & echo $!` |
| `fg`      | Brings a background job to the foreground. Bringing jobs to the foreground allows for interaction with processes that were previously running in the background.                   | `fg %1`              |
| `bg`      | Resumes a suspended job in the background. Resuming background tasks is useful for continuing processes that were paused without blocking the terminal.                            | `bg %1`              |
| `disown`  | Removes a job from the shell job table. Disowning a job prevents it from being terminated when the shell session ends, allowing it to run independently.                           | `disown %1`          |
| `kill`    | Sends a signal to a process, typically to terminate it. Useful for stopping processes that are not responding.                                                                     | `kill 1234`          |
| `killall` | Terminates all processes with the given name. This is useful for managing applications with multiple instances.                                                                    | `killall firefox`    |

### Conditional Expressions
| Condition               | Tests if . . .                     | Example                                                                                         |
|-------------------------|------------------------------------|-------------------------------------------------------------------------------------------------|
| `[[ -z $VAR ]]`         | `$VAR` is empty                    | `[[ -z $VAR ]]`<br>*Returns 0 if VAR is empty*                                                  |
| `[[ -n $VAR ]]`         | `$VAR` is not empty                | `[[ -n $VAR ]]`<br>*Returns 0 if VAR is not empty*                                              |
| `[[ -d $VAR ]]`         | `$VAR` is an existing directory    | `[[ -d /home ]]`<br>*Returns 0 if "/home" exists and is a directory (not a regular file)*       |
| `[[ -f $VAR ]]`         | `$VAR` is an existing regular file | `[[ -f file.txt ]]`<br>*Returns 0 if "file.txt" exists and is a regular file (not a directory)* |
| `[[ -L $VAR ]]`         | `$VAR` is a symbolic link          | `[[ -L file.txt ]]`<br>*Returns 0 if "file.txt" is a symlink*                                   |
| `[[ -r $VAR ]]`         | `$VAR` is a readable file          | `[[ -r file.txt ]]`<br>*Returns 0 if "file.txt" is human-readable*                              |
| `[[ -w $VAR ]]`         | `$VAR` is a writable file          | `[[ -w file.txt ]]`<br>*Returns 0 if "file.txt" is writable*                                    |
| `[[ -x $VAR ]]`         | `$VAR` is an executable file       | `[[ -x script.sh ]]`<br>*Returns 0 if "script.sh" is executable*                                |
| `[[ $VAR == pattern ]]` | `$VAR` matches a pattern           | `[[ $VAR == H* ]]`<br>*Returns 0 if VAR begins with "H"*                                        |
| `[[ $VAR != pattern ]]` | `$VAR` does not match a pattern    | `[[ $VAR != *[!0123456789]* ]]`<br>*Returns 0 if VAR only contains numerals 0-9*                |

### Error Handling and Debugging
| Command           | Description                                                                                                                                                                                                                                                                                         |
|-------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `set -e`          | Exit immediately if a command exits with a non-zero status. Useful for stopping script execution on errors, ensuring that failures are not silently ignored, leading to predictable script behavior.                                                                                                |
| `set -o pipefail` | Returns the exit status of the last command to fail in a pipeline. Ensures pipeline errors aren't ignored, making it easier to detect issues in multi-command pipelines. This is particularly helpful when piping several commands where the failure of any command should halt the entire process. |
| `set -o nounset`  | Treat unset variables as errors. Helps catch typos and misnamed variables by ensuring that all variables must be explicitly defined, reducing the likelihood of subtle bugs.                                                                                                                        |
| `set -o xtrace`   | Print commands and their arguments as they are executed. Useful for debugging scripts by providing detailed output of each command, showing how the script progresses and where issues might occur.                                                                                                 |

### Miscellaneous
| Command   | Description                                                                                                                                                                                                         | Example                            |
|-----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------|
| `alias`   | Creates an alias to shorten command usage, making commonly used commands quicker to type and more convenient.                                                                                                       | `alias ll='ls -la'`                |
| `unalias` | Removes a previously set alias, restoring the default behavior of the aliased command.                                                                                                                              | `unalias ll`                       |
| `export`  | Makes `VAR` available to child processes, which is crucial for passing configuration and context information to subshells and other commands.                                                                       | `export VAR=value`                 |
| `source`  | Runs commands from a file in the current shell, allowing for reusable scripts to modify the current shell environment. Useful for setting environment variables or functions without starting a new shell instance. | `source script.sh`                 |
| `trap`    | Captures a signal and executes a command. This is useful for cleaning up resources or providing user feedback when a script is interrupted, making scripts more robust and user-friendly.                           | `trap "echo 'Interrupted'" SIGINT` |
| `type`    | Shows how a command would be interpreted, whether it is a built-in, alias, or external command. Useful for troubleshooting command resolution.                                                                      | `type ls`                          |
| `which`   | Displays the full path of a shell command. Useful for verifying which version of a command is being used.                                                                                                           | `which bash`                       |


### System Information
| Command  | Description                                                                                                                                                                    | Example               |
|----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------|
| `uname`  | Displays detailed system information, which is useful for debugging or verifying system compatibility before running certain commands.                                         | `uname -a`            |
| `df`     | Displays available disk space on file systems, formatted in a human-readable way. Useful for monitoring storage and ensuring there is enough space before writing large files. | `df -h`               |
| `du`     | Shows the disk usage of a directory or file in summarized format, helpful for identifying large files or directories taking up space.                                          | `du -sh /path/to/dir` |
| `top`    | Provides a dynamic view of running processes, useful for monitoring system resource usage in real-time and identifying processes that consume excessive resources.             | `top`                 |
| `ps`     | Displays information about running processes, which is useful for checking the status of applications, finding process IDs, and identifying unwanted processes.                | `ps aux`              |
| `uptime` | Shows how long the system has been running along with the load average, providing insight into system stability and current load conditions.                                   | `uptime`              |
| `free`   | Shows the total, used, and available memory in human-readable format. Useful for assessing system performance and diagnosing memory issues.                                    | `free -h`             |
| `who`    | Displays a list of users currently logged into the system. Helpful for monitoring user activity and system usage.                                                              | `who`                 |
